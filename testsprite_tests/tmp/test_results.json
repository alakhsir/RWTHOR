[
  {
    "projectId": "160b5f52-b3c1-46c4-815d-b68b2c268a57",
    "testId": "1aa21edc-c554-4c72-bbdb-7434398980d2",
    "userId": "84e8c488-b001-70bf-64a9-1b52b7a6c949",
    "title": "TC001-User login success with valid credentials",
    "description": "Verify that a user can successfully log in with valid username/email and password credentials, and is redirected to the correct dashboard based on role.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Enter valid mobile number for login\n        frame = context.pages[-1]\n        # Enter valid mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9999999999')\n        \n\n        frame = context.pages[-1]\n        # Click on Send OTP button\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Check if email/password login is available or try another valid login method\n        frame = context.pages[-1]\n        # Click on Login with email option if available\n        elem = frame.locator('xpath=html/body/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Login Successful! Welcome to your dashboard').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: User login was not successful or user was not redirected to the correct dashboard as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login test cannot proceed due to lack of alternative login methods and OTP sending failure caused by Twilio unverified number error. Reporting issue and stopping test.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e8c488-b001-70bf-64a9-1b52b7a6c949/1768911219667444//tmp/test_task/result.webm",
    "created": "2026-01-20T12:11:17.864Z",
    "modified": "2026-01-20T12:13:39.786Z"
  },
  {
    "projectId": "160b5f52-b3c1-46c4-815d-b68b2c268a57",
    "testId": "7132e4fb-fac1-42eb-91f7-c7abfac2bccd",
    "userId": "84e8c488-b001-70bf-64a9-1b52b7a6c949",
    "title": "TC002-Admin login success with valid credentials",
    "description": "Verify that an admin can successfully log in with valid credentials and is redirected to the admin dashboard.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Enter valid admin username and password\n        frame = context.pages[-1]\n        # Enter admin mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9999999999')\n        \n\n        # -> Click on Send OTP button to proceed with login\n        frame = context.pages[-1]\n        # Click on Send OTP button\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Admin Dashboard Access Granted').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Admin login was unsuccessful or admin was not redirected to the admin dashboard as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Admin login failed due to OTP rate limit exceeded error, preventing successful login and redirection to admin dashboard. Test cannot proceed further.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 429 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e8c488-b001-70bf-64a9-1b52b7a6c949/1768911174422422//tmp/test_task/result.webm",
    "created": "2026-01-20T12:11:17.869Z",
    "modified": "2026-01-20T12:12:54.540Z"
  },
  {
    "projectId": "160b5f52-b3c1-46c4-815d-b68b2c268a57",
    "testId": "c2247c09-39c8-4109-bdb9-2d30bc5a258c",
    "userId": "84e8c488-b001-70bf-64a9-1b52b7a6c949",
    "title": "TC003-User login failure with invalid credentials",
    "description": "Verify that login fails with invalid credentials and appropriate error message is displayed.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Enter invalid mobile number and attempt login to verify failure and error message\n        frame = context.pages[-1]\n        # Enter invalid mobile number\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('0000000000')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button to attempt login with invalid mobile number\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Welcome Back').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Enter your mobile number to continue').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Error sending confirmation OTP to provider: \\'To\\' number cannot be a Short Code: +91000000XXXX').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=+91').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Send OTP').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e8c488-b001-70bf-64a9-1b52b7a6c949/1768911162626449//tmp/test_task/result.webm",
    "created": "2026-01-20T12:11:17.875Z",
    "modified": "2026-01-20T12:12:42.781Z"
  },
  {
    "projectId": "160b5f52-b3c1-46c4-815d-b68b2c268a57",
    "testId": "63ddf9c3-184a-424a-bd08-c46cd13ecf42",
    "userId": "84e8c488-b001-70bf-64a9-1b52b7a6c949",
    "title": "TC004-Route protection prevents unauthorized access",
    "description": "Verify that protected routes redirect unauthenticated users to login page and restrict access based on role.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Attempt to navigate to user dashboard without login to verify redirect to login page.\n        await page.goto('http://localhost:3000/#/user-dashboard', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Login as user by entering mobile number and sending OTP.\n        frame = context.pages[-1]\n        # Enter mobile number for user login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9999999999')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Check if there is an alternative login method or test with a verified number to proceed with login and role-based access test.\n        frame = context.pages[-1]\n        # Try alternative verified mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1234567890')\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Welcome Back').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Enter your mobile number to continue').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Mobile Number').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=+91').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Send OTP').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e8c488-b001-70bf-64a9-1b52b7a6c949/1768911198061821//tmp/test_task/result.webm",
    "created": "2026-01-20T12:11:17.881Z",
    "modified": "2026-01-20T12:13:18.196Z"
  },
  {
    "projectId": "160b5f52-b3c1-46c4-815d-b68b2c268a57",
    "testId": "57dc640a-8c90-4cbb-9b18-893cad13a258",
    "userId": "84e8c488-b001-70bf-64a9-1b52b7a6c949",
    "title": "TC005-Explore batches loads and displays batch list with details",
    "description": "Verify that the Explore Batches page loads successfully and displays the list of available batches with detailed information.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input mobile number and click Send OTP to authenticate as student user\n        frame = context.pages[-1]\n        # Input mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9999999999')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button to receive OTP\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Batch Enrollment Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Explore Batches page did not load successfully or batches are not listed with correct information such as batch name, start date, and enrollment options.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task to verify the Explore Batches page cannot be completed because login is blocked by a Twilio error related to unverified phone number preventing OTP sending. The issue has been reported. Please resolve the login issue to proceed with testing the Explore Batches page.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e8c488-b001-70bf-64a9-1b52b7a6c949/1768911172329197//tmp/test_task/result.webm",
    "created": "2026-01-20T12:11:17.887Z",
    "modified": "2026-01-20T12:12:52.452Z"
  },
  {
    "projectId": "160b5f52-b3c1-46c4-815d-b68b2c268a57",
    "testId": "177ad9b5-b129-403a-bcb8-b20ed6334e30",
    "userId": "84e8c488-b001-70bf-64a9-1b52b7a6c949",
    "title": "TC006-Enroll in batch triggers proper enrollment and updates My Batches",
    "description": "Verify that enrolling in a batch updates the user's enrolled batches and reflects accurately in the My Batches page.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input mobile number and click Send OTP to authenticate\n        frame = context.pages[-1]\n        # Input mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9999999999')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Enrollment Successful! Welcome to your new batch').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Enrollment confirmation was not shown after enrolling in a batch as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The enrollment test cannot be completed because the login process is blocked by an OTP sending failure due to an unverified phone number error from Twilio. This prevents authentication and further navigation to enroll in batches or verify enrollment. The issue has been reported. Task stopped.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e8c488-b001-70bf-64a9-1b52b7a6c949/1768911177615637//tmp/test_task/result.webm",
    "created": "2026-01-20T12:11:17.893Z",
    "modified": "2026-01-20T12:12:57.775Z"
  },
  {
    "projectId": "160b5f52-b3c1-46c4-815d-b68b2c268a57",
    "testId": "8aefbb5c-325e-43c0-8294-80828a9c3d17",
    "userId": "84e8c488-b001-70bf-64a9-1b52b7a6c949",
    "title": "TC007-View personal enrolled batches and progress",
    "description": "Verify that the My Batches page displays all enrolled batches and their progress accurately for the logged-in user.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input mobile number and click Send OTP to login\n        frame = context.pages[-1]\n        # Input mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9999999999')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button to receive OTP\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=No enrolled batches found').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The My Batches page did not display all enrolled batches and their progress accurately for the logged-in user as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The test to verify the My Batches page displaying all enrolled batches and their progress accurately could not be completed because login as a student user failed. The failure was due to an OTP sending error caused by the phone number being unverified in the Twilio trial account, blocking the login process. This prevented access to the My Batches page for verification. Please resolve the OTP sending issue or use a verified phone number to enable login and continue testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e8c488-b001-70bf-64a9-1b52b7a6c949/1768911178410087//tmp/test_task/result.webm",
    "created": "2026-01-20T12:11:17.899Z",
    "modified": "2026-01-20T12:12:58.550Z"
  },
  {
    "projectId": "160b5f52-b3c1-46c4-815d-b68b2c268a57",
    "testId": "2f535496-9293-49e9-b552-ce9c2c6d54a3",
    "userId": "84e8c488-b001-70bf-64a9-1b52b7a6c949",
    "title": "TC008-Course content navigation through subjects and chapters",
    "description": "Verify navigation inside a batch shows subjects and chapters correctly and users can drill down to chapter level content.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input mobile number and click Send OTP to authenticate.\n        frame = context.pages[-1]\n        # Input mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9999999999')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Nonexistent Subject Title for Batch Navigation Test').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Navigation inside a batch did not show subjects and chapters correctly, or users could not drill down to chapter level content as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The navigation test inside a batch to verify subjects and chapters could not be completed due to authentication failure. The OTP sending failed because the phone number used is unverified, blocking login. This issue was reported. Please use a verified phone number or alternative authentication method to proceed with the test.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e8c488-b001-70bf-64a9-1b52b7a6c949/1768911171499544//tmp/test_task/result.webm",
    "created": "2026-01-20T12:11:17.905Z",
    "modified": "2026-01-20T12:12:51.694Z"
  },
  {
    "projectId": "160b5f52-b3c1-46c4-815d-b68b2c268a57",
    "testId": "bafd10b3-e4c3-4ec3-b976-cc9e1ac6d110",
    "userId": "84e8c488-b001-70bf-64a9-1b52b7a6c949",
    "title": "TC009-Video player playback and controls functionality",
    "description": "Verify that the integrated video player in ChapterView plays lecture videos smoothly with working play, pause, seek, and volume controls.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input mobile number and click Send OTP to proceed with login\n        frame = context.pages[-1]\n        # Input mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9999999999')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button to request OTP\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Video playback completed successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The integrated video player did not play the lecture videos smoothly with working play, pause, seek, and volume controls as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login failed due to unverified phone number error from Twilio. Cannot proceed with video player test without successful login. Please provide a verified phone number or alternative authentication method to continue testing the video player.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e8c488-b001-70bf-64a9-1b52b7a6c949/1768911172648106//tmp/test_task/result.webm",
    "created": "2026-01-20T12:11:17.911Z",
    "modified": "2026-01-20T12:12:52.780Z"
  },
  {
    "projectId": "160b5f52-b3c1-46c4-815d-b68b2c268a57",
    "testId": "9621cdb2-8117-41a1-b723-5d8e989424ad",
    "userId": "84e8c488-b001-70bf-64a9-1b52b7a6c949",
    "title": "TC010-Access and download PDFs and DPPs without errors",
    "description": "Verify that related PDFs and Daily Practice Problems (DPPs) are accessible from course content and can be downloaded successfully.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input mobile number and send OTP to authenticate\n        frame = context.pages[-1]\n        # Input mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9999999999')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button to receive OTP\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Check for alternative authentication methods or use a verified number to proceed with login\n        frame = context.pages[-1]\n        # Input a different verified mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1234567890')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button to receive OTP\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Download Successful Confirmation').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Related PDFs and Daily Practice Problems (DPPs) are not accessible or downloadable as expected from the course content.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Authentication blocked due to SMS rate limit exceeded error. Unable to proceed with login to verify course content and download PDFs/DPPs. Please provide alternative authentication method or test credentials to continue.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e8c488-b001-70bf-64a9-1b52b7a6c949/1768911199542007//tmp/test_task/result.webm",
    "created": "2026-01-20T12:11:17.917Z",
    "modified": "2026-01-20T12:13:19.659Z"
  },
  {
    "projectId": "160b5f52-b3c1-46c4-815d-b68b2c268a57",
    "testId": "ff75abc9-c68c-49a5-972c-6db7bec05891",
    "userId": "84e8c488-b001-70bf-64a9-1b52b7a6c949",
    "title": "TC011-Quiz loads correctly and user responses are recorded",
    "description": "Verify that quizzes for course content load properly, accept user answers, and submit responses accurately.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input mobile number and click Send OTP to proceed with authentication\n        frame = context.pages[-1]\n        # Input mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9999999999')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button to request OTP\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Quiz Completed Successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The quiz did not load properly, user answers were not accepted, or responses were not submitted accurately as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "OTP sending failed due to unverified phone number error. Cannot proceed with login and quiz testing. Please use a verified phone number or alternative authentication method to continue testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e8c488-b001-70bf-64a9-1b52b7a6c949/17689111676367//tmp/test_task/result.webm",
    "created": "2026-01-20T12:11:17.923Z",
    "modified": "2026-01-20T12:12:47.763Z"
  },
  {
    "projectId": "160b5f52-b3c1-46c4-815d-b68b2c268a57",
    "testId": "5fdd58ba-15c4-40f9-9b32-1d4b2b75a82d",
    "userId": "84e8c488-b001-70bf-64a9-1b52b7a6c949",
    "title": "TC012-Admin creates new batch successfully",
    "description": "Verify that an admin can create a new batch using the CreateBatch page and it appears in the batch list afterwards.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input admin mobile number and click Send OTP to login\n        frame = context.pages[-1]\n        # Input admin mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9999999999')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button to request OTP\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Batch creation failed due to invalid input').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Admin was unable to create a new batch or the batch does not appear in the batch list as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Admin login via OTP is blocked due to Twilio trial account restrictions on unverified phone numbers. The login page only supports OTP login via mobile number and no alternative login methods are available. Without successful admin login, the test to create a new batch and verify it cannot proceed. Please provide verified admin credentials or an alternative login method to continue testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e8c488-b001-70bf-64a9-1b52b7a6c949/1768911192751008//tmp/test_task/result.webm",
    "created": "2026-01-20T12:11:17.929Z",
    "modified": "2026-01-20T12:13:12.885Z"
  },
  {
    "projectId": "160b5f52-b3c1-46c4-815d-b68b2c268a57",
    "testId": "2d74261c-695b-4dba-82dc-64920c9fff98",
    "userId": "84e8c488-b001-70bf-64a9-1b52b7a6c949",
    "title": "TC013-Admin manages content with EditableDropdown functionality",
    "description": "Verify that admin can edit and manage batch/course content using the ManageContent page and EditableDropdown component works as expected.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input admin mobile number and click Send OTP to login\n        frame = context.pages[-1]\n        # Input admin mobile number\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9999999999')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Content update successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Admin was unable to edit and manage batch/course content using the ManageContent page and EditableDropdown component as expected. Content updates did not persist or reflect correctly.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login as admin failed due to SMS rate limit exceeded error on OTP request. Cannot proceed with further steps of the test. Please reset the test environment or provide alternative login credentials or method.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 429 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e8c488-b001-70bf-64a9-1b52b7a6c949/1768911166988583//tmp/test_task/result.webm",
    "created": "2026-01-20T12:11:17.942Z",
    "modified": "2026-01-20T12:12:47.111Z"
  },
  {
    "projectId": "160b5f52-b3c1-46c4-815d-b68b2c268a57",
    "testId": "c030b4c3-f065-43d2-bfab-68d893391bc7",
    "userId": "84e8c488-b001-70bf-64a9-1b52b7a6c949",
    "title": "TC014-Profile displays current user information",
    "description": "Verify that the Profile page loads and displays accurate information of the logged-in user.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input mobile number and click Send OTP to login as student user\n        frame = context.pages[-1]\n        # Input student user mobile number\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9999999999')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=User Profile Information Verified Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Profile page did not load or display accurate user information as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task to verify the Profile page loading and displaying accurate user information could not be completed due to a login failure. The login failed because the OTP could not be sent to the unverified phone number, as indicated by the error message from Twilio. This issue was reported. Without successful login, navigation to the Profile page and verification of user information is not possible. Please resolve the login issue with a verified phone number or alternative authentication method to proceed with the test.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e8c488-b001-70bf-64a9-1b52b7a6c949/1768911183964554//tmp/test_task/result.webm",
    "created": "2026-01-20T12:11:17.948Z",
    "modified": "2026-01-20T12:13:04.108Z"
  },
  {
    "projectId": "160b5f52-b3c1-46c4-815d-b68b2c268a57",
    "testId": "64f71bd5-f547-4f5e-91af-cc84fe47bcd5",
    "userId": "84e8c488-b001-70bf-64a9-1b52b7a6c949",
    "title": "TC015-User updates profile information successfully",
    "description": "Verify that user can update profile details and changes are saved and reflected correctly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input mobile number and click Send OTP to proceed with login.\n        frame = context.pages[-1]\n        # Input mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9999999999')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button to receive OTP\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Check for alternative login methods or use a verified phone number to proceed with authentication.\n        frame = context.pages[-1]\n        # Input a verified mobile number for login attempt\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1234567890')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button to receive OTP\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Check for alternative login or navigation options to reach Profile page for testing.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Check if there is any hidden or alternative navigation or test login method to bypass OTP and reach Profile page.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        frame = context.pages[-1]\n        # Click on 'Welcome Back' text to check if it navigates or reveals alternative options\n        elem = frame.locator('xpath=html/body/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Profile update successful!').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: User profile update did not succeed or changes are not reflected as expected after saving, as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Task stopped: Cannot verify profile update functionality because login is blocked and no alternative navigation to Profile page is available.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e8c488-b001-70bf-64a9-1b52b7a6c949/1768911249245002//tmp/test_task/result.webm",
    "created": "2026-01-20T12:11:17.954Z",
    "modified": "2026-01-20T12:14:09.387Z"
  },
  {
    "projectId": "160b5f52-b3c1-46c4-815d-b68b2c268a57",
    "testId": "bfe6c985-e1f2-40b6-bac1-4a28ec4d67d1",
    "userId": "84e8c488-b001-70bf-64a9-1b52b7a6c949",
    "title": "TC016-Batch exploration shows appropriate empty state when no batches available",
    "description": "Verify the Explore Batches page displays an appropriate message or UI when no batches are available for enrollment.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input mobile number and click Send OTP to authenticate\n        frame = context.pages[-1]\n        # Input mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9999999999')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Check for alternative authentication methods or retry with a verified number\n        frame = context.pages[-1]\n        # Input a different mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('8888888888')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button to retry login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a verified mobile number and click Send OTP to authenticate successfully\n        frame = context.pages[-1]\n        # Input a verified mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9999999999')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=No batches available for enrollment').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test failed: The Explore Batches page did not display the appropriate empty state or message when no batches are available for enrollment as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Unable to proceed with the test due to SMS rate limit exceeded error blocking authentication. Please provide a verified test account or alternative authentication method to continue testing the Explore Batches page for empty batch state.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 429 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e8c488-b001-70bf-64a9-1b52b7a6c949/1768911225950956//tmp/test_task/result.webm",
    "created": "2026-01-20T12:11:17.959Z",
    "modified": "2026-01-20T12:13:46.075Z"
  },
  {
    "projectId": "160b5f52-b3c1-46c4-815d-b68b2c268a57",
    "testId": "c99395dc-ec3c-47af-9443-e6eea1068798",
    "userId": "84e8c488-b001-70bf-64a9-1b52b7a6c949",
    "title": "TC017-Application routing handles invalid URLs gracefully",
    "description": "Verify that navigating to invalid or non-existent URLs results in appropriate 404 or fallback pages without crashing the app.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input valid mobile number and send OTP to authenticate before testing invalid URLs.\n        frame = context.pages[-1]\n        # Input a valid mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9999999999')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Welcome to the Dashboard').first).to_be_visible(timeout=5000)\n        except AssertionError:\n            raise AssertionError('Test failed: Navigating to invalid URLs did not display a 404 or Not Found page as expected, indicating the app may have crashed or dead-ended.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The test to verify navigation to invalid or non-existent URLs resulting in appropriate 404 or fallback pages could not be fully performed due to an SMS rate limit exceeded error blocking authentication. The issue has been reported. Further testing requires resolving this authentication block.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 429 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e8c488-b001-70bf-64a9-1b52b7a6c949/1768911172758654//tmp/test_task/result.webm",
    "created": "2026-01-20T12:11:17.965Z",
    "modified": "2026-01-20T12:12:52.886Z"
  },
  {
    "projectId": "160b5f52-b3c1-46c4-815d-b68b2c268a57",
    "testId": "92a1a802-df49-4cad-b939-7d78fc800489",
    "userId": "84e8c488-b001-70bf-64a9-1b52b7a6c949",
    "title": "TC018-Quiz handles incomplete or invalid user input correctly",
    "description": "Verify that the quiz interface properly handles incomplete submissions or invalid input and provides proper feedback to the user.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input a valid mobile number and click Send OTP to proceed with authentication.\n        frame = context.pages[-1]\n        # Input a valid mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9999999999')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button to receive OTP and proceed\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to quiz page or find a way to access quiz interface to test incomplete submission handling.\n        await page.goto('http://localhost:3000/#/quiz', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Attempt to send OTP with the entered mobile number to proceed with authentication.\n        frame = context.pages[-1]\n        # Click Send OTP button to attempt sending OTP for authentication\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Quiz Completed Successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError('Test failed: The quiz interface did not handle incomplete submissions or invalid input properly. Expected prompt or feedback for unanswered questions was not found.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing cannot proceed because the authentication flow is blocked at the login page. The Send OTP button disables but no further steps appear, preventing access to the quiz interface. Please resolve the login issue to enable testing of quiz submission handling.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e8c488-b001-70bf-64a9-1b52b7a6c949/1768911236004194//tmp/test_task/result.webm",
    "created": "2026-01-20T12:11:17.971Z",
    "modified": "2026-01-20T12:13:56.133Z"
  },
  {
    "projectId": "160b5f52-b3c1-46c4-815d-b68b2c268a57",
    "testId": "e393f7bf-cc6c-40bd-973a-33a6e20ad78b",
    "userId": "84e8c488-b001-70bf-64a9-1b52b7a6c949",
    "title": "TC019-Critical pages load within performance thresholds",
    "description": "Verify that key pages (Home, Dashboard, Chapter View) load and become interactive within acceptable time limits (e.g., under 3 seconds) to ensure optimal user experience.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input mobile number and send OTP to login and measure Home page load time.\n        frame = context.pages[-1]\n        # Input mobile number for login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('9999999999')\n        \n\n        frame = context.pages[-1]\n        # Click Send OTP button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div/div[3]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Page Load Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The test plan execution has failed because the key pages (Home, Dashboard, Chapter View) did not load and become interactive within the acceptable time limits of under 3 seconds.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Cannot proceed with performance testing of key pages because login is blocked by Twilio unverified phone number error. Please resolve authentication issue to continue.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://fmdxczzttnpnnzdftsnd.supabase.co/auth/v1/otp:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84e8c488-b001-70bf-64a9-1b52b7a6c949/1768911170841218//tmp/test_task/result.webm",
    "created": "2026-01-20T12:11:17.976Z",
    "modified": "2026-01-20T12:12:50.957Z"
  }
]
